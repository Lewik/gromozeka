# Context Management System

## Концепция

**Проблема**: Нужно эффективно выделять и передавать контексты из разговоров для различных сценариев:
- Когда контекстное окно Claude Code заканчивается
- Выделить что-то посреди разговора для параллельного обсуждения  
- Закончил планирование и хочу свежее окно для имплементации
- Самоперезапуск (открыть новую табу, старую закрыть)

**Решение**: Система извлечения и управления контекстами, которая:
1. Анализирует разговор и выделяет отдельные смысловые области (контексты)
2. Структурирует каждый контекст в JSON формате для дальнейшего использования
3. Предоставляет UI для управления сохраненными контекстами

## Архитектура

### Основной поток
```
UI кнопка/MCP extract_context → ContextExtractionService → создать фоновую табу → 
→ resume текущей сессии → загрузить MD инструкцию → 
→ Claude анализирует разговор → формирует XML → вызывает MCP с XML → 
→ ContextFileService: XML→MD файлы → git commit + push → UI для управления контекстами
```

## Структура Контекста

### XML формат (промежуточный - от Claude)

```xml
<contexts>
  <context>
    <name>краткое название темы</name>
    <project_path>абсолютный путь к проекту</project_path>
    <files>
      <file path="path/to/file.kt">readfull</file>
      <file path="path/to/other.kt">
        <item>fun methodName</item>
        <item>class ClassName</item>
        <item>142:156</item>
      </file>
    </files>
    <links>
      <link>https://example.com/relevant-doc</link>
    </links>
    <content>ключевая и достаточная информация по данному контексту</content>
  </context>
</contexts>
```

### MD формат (итоговый файл)

```markdown
# Название контекста
> Краткое описание контекста

## Project Path
/Users/lewik/code/gromozeka/dev

## Files to Read
- `Session.kt` - readfull
- `SessionManager.kt` - fun startSession, fun resumeSession  
- `ClaudeWrapper.kt` - 142:156

## Links
- https://example.com/docs

## Context
ключевая и достаточная информация по данному контексту

---
*Извлечено: 2025-01-22T10:30:00Z*
```

**Примечания:**
- Claude формирует XML, ContextFileService конвертирует в MD
- Каждый контекст = отдельный MD файл готовый для использования

## Детальный План Реализации

### Этап 1: Core Service
**1.1** Создать `ContextExtractionService.kt`
- Метод `extractContextsFromTab(tabId: String)`
- Получение Claude Code session ID из текущей табы
- Создание фоновой табы с resume существующей сессии

**1.2** Интеграция с TabViewModel
- Добавить метод для получения session ID текущей табы
- Добавить вызов ContextExtractionService из ViewModel

**1.3** Создание фоновой табы с resume
- Внутренняя логика использования `mcp__gromozeka-self-control__open_tab` с `resume_session_id`
- **Ключевая особенность**: resume создает НОВЫЙ session ID с полной копией истории (см. "Claude Code CLI Особенности")
- Загрузка MD файла как `initial_message`
- Установка `set_as_current = false` (работа в фоне)
- **Результат**: фоновая таба с полной копией разговора готова для анализа

### Этап 2: UI Integration  
**2.1** Добавить кнопку в SessionScreen.kt
- Кнопка "Extract Contexts" в основном UI
- Вызов `ContextExtractionService.extractContexts()`

**2.2** Обновить MD инструкцию
- Добавить в конец `context-extraction-instructions.md`
- Инструкция автоматически вызвать MCP с результатом в XML формате
- Указать что нужно вызвать `mcp__gromozeka-self-control__save_contexts` с XML
- **Рассмотреть подходы memory-manager агента** к структурированным MD файлам при создании финального формата

### Этап 3: MCP Tools
**3.1** Создать `ExtractContextsTool.kt` (`mcp__gromozeka-self-control__extract_context`)
- MCP tool для запуска процесса извлечения контекста
- Параметр: `tabId` (опционально - по умолчанию текущая таба)
- Внутри вызывает `ContextExtractionService.extractContextsFromTab(tabId)`
- ContextExtractionService делает всю работу включая открытие фоновой табы

**3.2** Создать `SaveContextsTool.kt` (`mcp__gromozeka-self-control__save_contexts`)
- MCP tool для получения XML результата от Claude
- **XML валидация**: проверка корректности XML структуры
- **Error handling**: если XML невалидный → вернуть ошибку обратно Claude для исправления
- Парсинг XML и конвертация в MD файлы через ContextFileService
- Уведомление UI об успешном сохранении контекстов

### Этап 4: File Management
**4.1** Создать структуру директорий
- Расположение: `~/.gromozeka/contexts/` (совместимо с существующей системой)
- Формат имен файлов: `2025-01-22_session-resume-bug_<guid>.md`

**4.2** Создать `ContextFileService.kt`
- **XML парсинг с валидацией**: проверка структуры, обязательных полей, корректности вложений
- **Error reporting**: детальные сообщения об ошибках XML для Claude (какое поле, какая проблема)
- Конвертация data classes в структурированные MD файлы
- Генерация GUID для уникальных имен файлов
- Получение списка доступных сохраненных контекстов
- Валидация XML и MD структуры
- **Git операции**: автоматический commit + push при сохранении/удалении
- **Git инициализация**: создание репозитория если отсутствует

**4.3** Создать кодек XML ↔ Data Classes ↔ MD (отдельная задача)
- XML парсер/сериализатор для ContextItem
- MD парсер/генератор для структурированного формата  
- **Изучить инструкции memory-manager агента** (`/Users/lewik/code/aiprofile/claude-home/agents/memory-manager.md`)
- Принять во внимание подходы к структурированным MD файлам из существующей системы памяти
- Обработка edge cases и валидация

**4.4** Создать Git Integration Service
- **Инициализация git**: Автоматическое создание `.git` если репозиторий отсутствует
- **Auto-commit workflow**: 
  - При сохранении контекста: `git add . && git commit -m "Add context: название"`
  - При удалении контекста: `git add . && git commit -m "Delete context: название"`
- **Auto-push**: `git push origin main` после каждого коммита
- **Обработка конфликтов**: Базовая стратегия разрешения (или уведомление пользователя)
- **Remote setup**: Возможность настройки remote origin для синхронизации

### Этап 5: Testing & Validation
**5.1** **КРИТИЧНО**: Проверка Resume Behavior  
- Проверить что `claude --resume` действительно создает полную копию разговора
- Убедиться что фоновая таба имеет доступ ко всей истории
- Если не работает → разработать альтернативный механизм

**5.2** Тестирование UI кнопки
- Проверка создания фоновой табы
- Проверка загрузки MD инструкции

**5.3** Тестирование MCP tool из Claude Code
- Возможность запуска через Claude Code CLI
- Корректная передача параметров

**5.4** Проверка создания XML и MD
- Валидация XML структуры от Claude
- **Тестирование error handling**: невалидный XML → ошибка → исправление → повторная попытка
- Проверка корректности конвертации XML→MD
- Проверка корректности извлеченных контекстов

**5.5** Проверка файлового сохранения
- Корректное создание MD файлов
- Уникальность имен файлов
- Читаемость MD структуры

**5.6** Тестирование Git Integration
- Проверка автоматической инициализации git репозитория
- Проверка auto-commit при создании/удалении контекстов
- Проверка auto-push в remote (если настроен)
- Проверка корректности commit сообщений
- Тестирование обработки git конфликтов

### Этап 6: Contexts Management UI
**6.1** Создать `ContextsPanel.kt` (боковая панель)
- Список сохраненных контекстов с названиями
- Кнопка "Extract Contexts" (перенести из основного UI)
- Кнопка "Refresh" для обновления списка контекстов

**6.2** Операции с контекстами:
- **Кнопка "Start"** → создать новую табу с выбранным контекстом как initial_message
- **Кнопка "View"** → открыть MD файл в IDE через `idea /path/to/context.md`  
- **Кнопка "Delete"** → удалить файл контекста с подтверждением + автоматический git commit/push

**6.3** Интеграция панели в основной UI
- Добавить toggle кнопку для показа/скрытия боковой панели
- Разместить сбоку аналогично SettingsPanel
- Сохранение состояния панели (открыта/закрыта)

### Этап 7: Data Models & Serialization
**7.1** Создать data classes для контекстов:
```kotlin
data class ContextItem(
    val name: String,
    val project_path: String,
    val files: Map<String, ContextFileSpec>,
    val links: List<String> = emptyList(),
    val content: String,
    val extractedAt: String? = null // добавляется при сохранении
)

sealed class ContextFileSpec {
    object ReadFull : ContextFileSpec()
    data class Specific(val items: List<String>) : ContextFileSpec()
}
```

**7.2** Claude возвращает список контекстов в XML:
```kotlin
data class ExtractedContexts(
    val contexts: List<ContextItem>
)
```

**7.3** Поток конвертации: XML → Data Classes → MD файлы
- XML парсится в `ExtractedContexts` 
- Каждый `ContextItem` сохраняется в отдельный MD файл
- `extractedAt` добавляется автоматически при сохранении

## Технические Детали

### Файловая Организация
- **Директория**: `~/.gromozeka/contexts/` (git репозиторий)
- **Формат файлов**: Markdown (.md) с структурированным контекстом
- **Формат имен**: `YYYY-MM-DD_краткое-название_<GUID>.md`
- **Пример**: `2025-01-22_session-resume-bug_a1b2c3d4.md`

### Git Версионность
- **Автоматические коммиты**: При создании/удалении/изменении контекстов
- **Автоматический push**: Для синхронизации и резервного копирования
- **Commit сообщения**: `"Add context: краткое-название"`, `"Delete context: краткое-название"`
- **Безопасность**: Защита от потери данных, история изменений, восстановление
- **Инициализация**: Автоматическое создание git репозитория если отсутствует

### Error Handling
- Базовый принцип: fail fast - если что-то критично не работает, показать ошибку
- Логирование всех этапов процесса для отладки
- **XML валидация**: если Claude создает невалидный XML → ошибка возвращается для исправления
- **Retry механизм**: Claude может исправить XML и повторить вызов MCP tool
- Graceful degradation где возможно

### Claude Code CLI Особенности
**Resume Behavior (критически важно для архитектуры):**
- При вызове `claude --resume <session_id>` Claude Code CLI создает **НОВЫЙ session ID** вместо продолжения с тем же ID
- **Подтвержденный факт**: новый session ID создается точно
- **Непроверенное предположение**: это позволяет создать "ветку" разговора - копию всей истории с возможностью независимого развития
- **Используется в архитектуре**: для создания фоновой табы с полной копией текущего разговора для анализа контекстов

**Если предположение неверно**: потребуется альтернативный механизм получения полной истории разговора для анализа.

### Интеграция с Существующей Архитектурой
- Использование существующих MCP tools pattern
- Интеграция с TabViewModel и SessionManager
- Совместимость с текущей системой табов

### Связь с Memory-Manager Агентом
**Важно рассмотреть**: Инструкции memory-manager агента (`/Users/lewik/code/aiprofile/claude-home/agents/memory-manager.md`)

**Общие аспекты:**
- Оба работают со структурированными MD файлами
- Memory-manager использует модульную систему с четкими форматами
- Опыт валидации дубликатов и конфликтов
- Подходы к языковым требованиям (русский/английский)

**Потенциальная интеграция:**
- Возможность сохранения контекстов как модулей в aiprofile системе
- Переиспользование форматирования и валидации из memory-manager
- Унификация подходов к структурированным MD файлам

**Требует изучения**: Как memory-manager структурирует MD файлы для возможного переиспользования подходов

## Будущие Улучшения

### Возможные Расширения
- Поиск по содержимому контекстов
- Группировка контекстов по проектам
- Экспорт/импорт контекстов
- Интеграция с существующей системой памяти (`~/code/contexts/`)
- Автоматическое извлечение контекстов при приближении к лимиту
- **Интеграция с memory-manager**: Унификация подходов к структурированным MD файлам
- **Модульная система контекстов**: По аналогии с aiprofile modules для лучшей организации
- **Расширенная git интеграция**: 
  - Синхронизация между устройствами через GitHub/GitLab
  - Git history браузер в UI для просмотра версий контекстов
  - Автоматические backup на разные remotes
  - Branch management для экспериментов с контекстами

### UI/UX Улучшения
- Превью контекста в панели
- Drag & drop для организации
- Поиск и фильтрация контекстов
- Групповые операции (bulk delete, bulk start)

## Заметки по Реализации

1. **Не перегружать**: Начать с базового функционала, расширения потом
2. **Тестирование на каждом этапе**: Убедиться что каждый компонент работает перед переходом к следующему
3. **Совместимость**: Следовать существующим паттернам в кодебазе
4. **Производительность**: Фоновые операции не должны блокировать основной UI
5. **Изучение memory-manager**: Обязательно рассмотреть опыт memory-manager агента при работе со структурированными MD файлами
6. **Git безопасность**: Все git операции должны быть безопасными (не перезаписывать пользовательские изменения, корректно обрабатывать конфликты)

---

*Документ создан для планирования Context Management системы в Gromozeka. Обновляется по мере развития проекта.*