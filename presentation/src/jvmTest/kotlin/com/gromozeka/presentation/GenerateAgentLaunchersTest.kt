package com.gromozeka.presentation

import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.KotlinFeature
import com.fasterxml.jackson.module.kotlin.KotlinModule
import com.fasterxml.jackson.module.kotlin.readValue
import org.junit.jupiter.api.Test
import java.io.File

class GenerateAgentLaunchersTest {

    private val objectMapper = ObjectMapper()
        .registerModule(
            KotlinModule.Builder()
                .withReflectionCacheSize(512)
                .configure(KotlinFeature.NullToEmptyCollection, false)
                .configure(KotlinFeature.NullToEmptyMap, false)
                .configure(KotlinFeature.NullIsSameAsDefault, false)
                .configure(KotlinFeature.SingletonSupport, false)
                .configure(KotlinFeature.StrictNullChecks, false)
                .build()
        )
        .configure(com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)

    data class AgentConfig(
        val id: String,
        val name: String,
        val prompts: List<String>,
        val description: String
    )

    @Test
    fun generateAgentLaunchers() {
        // Find project root (tests run in :presentation module, go up one level)
        val currentDir = File(System.getProperty("user.dir"))
        val projectRoot = if (currentDir.name == "presentation") {
            currentDir.parentFile
        } else {
            currentDir
        }
        println("Project root: ${projectRoot.absolutePath}")

        // Output directory
        val outputDir = File(projectRoot, ".gromozeka/claude")
        println("Output directory: ${outputDir.absolutePath}")

        // Clean and recreate output directory
        outputDir.deleteRecursively()
        outputDir.mkdirs()

        // Agent directories
        val builtinAgentsDir = File(projectRoot, "presentation/src/jvmMain/resources/agents")
        val projectAgentsDir = File(projectRoot, ".gromozeka/agents")

        val allAgents = mutableListOf<Pair<File, AgentConfig>>()

        // Collect builtin agents
        if (builtinAgentsDir.exists()) {
            builtinAgentsDir.listFiles { file -> file.extension == "json" }?.forEach { file ->
                val config = objectMapper.readValue<AgentConfig>(file)
                allAgents.add(file to config)
            }
        }

        // Collect project agents
        if (projectAgentsDir.exists()) {
            projectAgentsDir.listFiles { file -> file.extension == "json" }?.forEach { file ->
                val config = objectMapper.readValue<AgentConfig>(file)
                allAgents.add(file to config)
            }
        }

        println("Found ${allAgents.size} agents to generate")

        // Generate launcher for each agent
        allAgents.forEach { (sourceFile, config) ->
            generateLauncher(sourceFile, config, outputDir, projectRoot)
        }

        println("")
        println("✓ Generated ${allAgents.size} agent launchers in ${outputDir.absolutePath}")
        println("")
        println("Usage examples:")
        println("  .gromozeka/claude/${allAgents.firstOrNull()?.second?.id}.sh")
        println("  .gromozeka/claude/${allAgents.firstOrNull()?.second?.id}.sh -c 'your command'")
        println("  .gromozeka/claude/${allAgents.firstOrNull()?.second?.id}.sh --model opus")
    }

    private fun generateLauncher(sourceFile: File, config: AgentConfig, outputDir: File, projectRoot: File) {
        println("Generating launcher for agent: ${config.id}")

        val launcherFile = File(outputDir, "${config.id}.sh")

        // Assemble system prompt by reading files directly
        val systemPrompt = try {
            assembleSystemPrompt(config.prompts, projectRoot)
        } catch (e: Exception) {
            println("Warning: Failed to assemble prompt for ${config.id}: ${e.message}")
            ""
        }

        // Get relative path to source JSON
        val relativeSourcePath = sourceFile.relativeTo(projectRoot).path

        // Prepare prompts list for debug output
        val promptsList = config.prompts.joinToString("\n") { "  - $it" }

        // Generate bash script
        val scriptContent = """
            |#!/bin/bash
            |
            |# Agent launcher script for: ${config.name}
            |# Generated by GenerateAgentLaunchersTest
            |# Description: ${config.description}
            |# Config: $relativeSourcePath
            |
            |set -e
            |
            |# Determine project root (this script is in .gromozeka/claude/)
            |SCRIPT_DIR="${'$'}(cd "${'$'}(dirname "${'$'}{BASH_SOURCE[0]}")" && pwd)"
            |PROJECT_ROOT="${'$'}(cd "${'$'}SCRIPT_DIR/../.." && pwd)"
            |
            |# Change to project root
            |cd "${'$'}PROJECT_ROOT"
            |
            |# Print debug info
            |echo "Agent: ${config.name} (${config.id})"
            |echo "Config: $relativeSourcePath"
            |echo "Prompts loaded:"
            |${promptsList.split("\n").joinToString("\n") { "echo \"$it\"" }}
            |echo ""
            |
            |# Create temporary file for system prompt
            |TEMP_PROMPT=${'$'}(mktemp)
            |trap "rm -f ${'$'}TEMP_PROMPT" EXIT
            |
            |# Write system prompt to temp file
            |cat > "${'$'}TEMP_PROMPT" << 'PROMPT_EOF'
            |${systemPrompt.replace("$", "\\$")}
            |PROMPT_EOF
            |
            |# Launch Claude Code
            |NODE_OPTIONS="--max-old-space-size=8192" claude \
            |    --model sonnet \
            |    --verbose \
            |    --setting-sources "" \
            |    --system-prompt-file "${'$'}TEMP_PROMPT" \
            |    "${'$'}@"
        """.trimMargin()

        launcherFile.writeText(scriptContent)
        launcherFile.setExecutable(true)

        println("Created: ${launcherFile.absolutePath}")
    }

    private fun assembleSystemPrompt(promptPaths: List<String>, projectRoot: File): String {
        val separator = "\n\n---\n\n"

        return promptPaths.joinToString(separator) { promptPath ->
            when {
                promptPath == "env" -> {
                    // Generate environment info
                    buildString {
                        appendLine("# Environment Information")
                        appendLine()
                        appendLine("Working directory: ${projectRoot.absolutePath}")
                        appendLine("Date: ${java.time.LocalDateTime.now()}")
                    }
                }

                promptPath.startsWith("prompts/") -> {
                    // Builtin prompt from resources
                    val resourcePath = "/prompts/${promptPath.removePrefix("prompts/")}"
                    val resource = javaClass.getResourceAsStream(resourcePath)
                    if (resource != null) {
                        resource.bufferedReader().use { it.readText() }
                    } else {
                        "⚠️ CRITICAL ERROR: Required prompt not loaded\n**Failed to load prompt:** $promptPath"
                    }
                }

                else -> {
                    // Project prompt
                    val file = File(projectRoot, promptPath)
                    if (file.exists()) {
                        file.readText()
                    } else {
                        "⚠️ CRITICAL ERROR: Required prompt not loaded\n**Failed to load prompt:** $promptPath"
                    }
                }
            }
        }
    }
}
